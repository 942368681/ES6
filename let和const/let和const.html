<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*
				let:
					声明变量（var类似）
				const:
					声明常量（常量为不可变化的量）
				
				let:
					1.使用let声明的变量只在命令所在的代码块中有效
					2.试用let声明的变量在域解析时不会被提升
					3.let不允许在同一个作用域下声明已经存在的变量
					4.暂时性死区
				const:
					1.使用const声明的常量只在命令所在的代码块中有效
					2.试用const声明的常量在域解析时不会被提升
					3.const不允许在同一个作用域下声明已经存在的常量
					4.声明的时候必须赋值
					5.const声明的常量，若常量是简单的数据类型，那么不可改变其值
					  const声明的常量，若常量是对象，那么不可改变其引用，至于对象中的数据如何变化无所谓
			*/
			
			//暂时性死区
				let f=10;
				function fn(){
					f=7;
					let f=2;
				};
				fn();//报错！
				/*
					只要块级作用域内存在let命令，它所声明的变量就'绑定'这个区域 ，不再受外部影响，上述代码中存在全局变量f，但是块级作用域内又let声明了一个局部变量f，导致后者绑定这个块级作用域，所以在let声明前对f赋值会报错
					ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
					总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的，这在语法上成为'暂时性死区'
				*/
		</script>
	</body>
</html>
